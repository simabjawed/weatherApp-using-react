/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {Plugin} from 'workbox-background-sync/Plugin.mjs';
import {cacheNames} from 'workbox-core/_private/cacheNames.mjs';
import {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';
import {logger} from 'workbox-core/_private/logger.mjs';
import {Route} from 'workbox-routing/Route.mjs';
import {Router} from 'workbox-routing/Router.mjs';
import {NetworkFirst} from 'workbox-strategies/NetworkFirst.mjs';
import {NetworkOnly} from 'workbox-strategies/NetworkOnly.mjs';
import {
  QUEUE_NAME,
  MAX_RETENTION_TIME,
  GOOGLE_ANALYTICS_HOST,
  GTM_HOST,
  ANALYTICS_JS_PATH,
  GTAG_JS_PATH,
  GTM_JS_PATH,
  COLLECT_PATHS_REGEX,
} from './utils/constants.mjs';
import './_version.mjs';

/**
 * Creates the requestWillDequeue callback to be used with the background
 * sync queue plugin. The callback takes the failed request and adds the
 * `qt` param based on the current time, as well as applies any other
 * user-defined hit modifications.
 *
 * @param {Object} config See workbox.googleAnalytics.initialize.
 * @return {Function} The requestWillDequeu callback function.
 *
 * @private
 */
const createOnSyncCallback = (config) => {
  return async ({queue}) => {
    let entry;
    while (entry = await queue.shiftRequest()) {
      const {request, timestamp} = entry;
      const url = new URL(request.url);

      try {
        // Measurement protocol requests can set their payload parameters in
        // either the URL query string (for GET requests) or the POST body.
        const params = request.method === 'POST' ?
            new URLSearchParams(await request.clone().text()) :
            url.searchParams;

        // Calculate the qt param, accounting for the fact that an existing
        // qt param may be present and should be updated rather than replaced.
        const originalHitTime = timestamp - (Number(params.get('qt')) || 0);
        const queueTime = Date.now() - originalHitTime;

        // Set the qt param prior to applying hitFilter or parameterOverrides.
        params.set('qt', queueTime);

        // Apply `paramterOverrideds`, if set.
        if (config.parameterOverrides) {
          for (const param of Object.keys(config.parameterOverrides)) {
            const value = config.parameterOverrides[param];
            params.set(param, value);
          }
        }

        // Apply `hitFilter`, if set.
        if (typeof config.hitFilter === 'function') {
          config.hitFilter.call(null, params);
        }

        // Retry the fetch. Ignore URL search params from the URL as they're
        // now in the post body.
        await fetch(new Request(url.origin + url.pathname, {
          body: params.toString(),
          method: 'POST',
          mode: 'cors',
          credentials: 'omit',
          headers: {'Content-Type': 'text/plain'},
        }));


        if (process.env.NODE_ENV !== 'production') {
          logger.log(`Request for '${getFriendlyURL(url.href)}'` +
             `has been replayed`);
        }
      } catch (err) {
        await queue.unshiftRequest(entry);

        if (process.env.NODE_ENV !== 'production') {
          logger.log(`Request for '${getFriendlyURL(url.href)}'` +
             `failed to replay, putting it back in the queue.`);
        }
        throw err;
      }
    }
    if (process.env.NODE_ENV !== 'production') {
      logger.log(`All Google Analytics request successfully replayed; ` +
          `the queue is now empty!`);
    }
  };
};
